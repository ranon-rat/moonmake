# Moonmake Documentation

Moonmake is a lightweight build system designed for C++ projects inspired by makefile, with a focus on simplicity and ease of use. It provides a Python-based interface for managing dependencies, compiling code, and handling project builds with incremental compilation support.

## Core Concepts

### Project Structure
```
project/
├── .moonmake/
│   ├── bin/          # Compiled binaries
│   ├── obj/          # Object files
│   ├── lib/          # Generated libraries
│   └── dependencies/ # External dependencies
│       ├── headers/  # Header files
│       └── lib/      # Library files
├── src/
│   ├── include/      # Project header files
│   ├── lib/          # Library source files
│   └── target/       # Main executable sources
└── build.py          # Build configuration
```

### Builder System

The Builder system manages the compilation process through rules that define how files should be built and their dependencies. It supports incremental compilation using dependency files (.d) generated by GCC.

Key features:
- **Automatic dependency tracking**: Uses GCC-generated .d files to track header dependencies
- **Incremental builds**: Only recompiles files when source or header dependencies change
- **Support for static libraries**: Automatic library creation and linking
- **Cross-platform compatibility**: Works on Windows, Linux, and macOS

### Dependency Files (.d) and Incremental Compilation

Moonmake uses GCC's dependency generation feature to create `.d` files that track which header files each source file depends on. This enables intelligent incremental compilation.

#### How it works:
1. **Generation**: When compiling with `-MMD -MP` flags, GCC creates `.d` files alongside `.o` files
2. **Content**: Each `.d` file contains a list of all header files that the source file includes
3. **Tracking**: Moonmake reads these `.d` files to determine if recompilation is needed
4. **Decision**: If any header file is newer than the object file, recompilation occurs

#### Example dependency file content:
```makefile
# main.o.d
main.o: main.cpp \
  src/include/game.h \
  src/include/utils.h \
  .moonmake/dependencies/headers/raylib/raylib.h
```

#### Benefits:
- **Fast builds**: Only changed files are recompiled
- **Accurate tracking**: Catches header file changes that affect compilation
- **Automatic**: No manual dependency specification required

### Common Commands

```bash
# Create a new project
moonmake-new -n project_name

# Install dependencies
python build.py install

# Build the project
python build.py
```

## Core Functions Reference

### Directory and Path Functions

#### `mmake.get_dir(__file__)`
Returns the relative path of the current directory from the workspace root.

#### `mmake.get_extension()`
Returns the appropriate executable extension for the current platform:
- Windows: `.exe`
- Linux/macOS: `""` (no extension)

### File Management

#### `mmake.discover(directory, endswith)`
Recursively finds all files in a directory that end with a specific extension. Returns a list of relative paths.

```python
# Find all .cpp files in src/lib
cpp_files = mmake.discover("src/lib", ".cpp")
# Result: ["main.cpp", "utils/helper.cpp", "math/vector.cpp"]
```

#### `mmake.change_extension(files, new_path, old="", new="")`
Changes the extension of files and optionally moves them to a new directory. Returns a list of new file paths.

```python
obj_files = mmake.change_extension(
    cpp_files,
    join(dir_path, ".moonmake", "obj"),
    old=".cpp",
    new=".o"
)
# Result: [".moonmake/obj/main.o", ".moonmake/obj/utils/helper.o", ".moonmake/obj/math/vector.o"]
```

### Dependency Management

#### `mmake.download_dependency(url, name, target_dir, headers=["include"])`
Downloads and installs an external dependency. Returns nothing, but sets up the dependency in the target directory.

```python
# Example: Download and install raylib
mmake.download_dependency(
    "https://github.com/raysan5/raylib/releases/download/5.5/raylib-5.5_win64_mingw-w64.zip",
    "raylib",                # Name of the dependency
    ".moonmake/dependencies", # Where to install
    headers=["include"]      # Which directories to copy as headers
)

# Example: Download a custom library
mmake.download_dependency(
    "https://example.com/mylib.zip",
    "mylib",
    ".moonmake/dependencies",
    headers=["include", "src/headers"]  # Multiple header directories
)
```

### Build System

#### `mmake.Builder()`
Creates a new build system instance. The Builder manages the compilation process and dependencies with support for incremental builds.

#### `builder.watch(targets, dependencies, command, extra_dependencies=[], show_command=True, dependency_file=False)`
Defines a build rule that specifies how to build target files from their dependencies.

**Parameters:**
- `targets`: List of files to build (output files)
- `dependencies`: List of files that targets depend on (input files)
- `command`: Shell command to execute (supports special variables)
- `extra_dependencies`: Additional files to watch for changes
- `show_command`: Whether to print the command being executed
- `dependency_file`: Enable .d file tracking for incremental builds

**When to use `dependency_file=True`:**
- For C/C++ compilation that generates object files
- When using `-MMD -MP` compiler flags
- To enable automatic header dependency tracking

#### Special Variables in Build Rules
When defining build rules with `builder.watch()`, you can use these special variables:
- `$@`: Represents the target file(s) being built
- `$<`: Represents the dependency at the index position of the target file (e.g., if target[0] is being built, $< will be dependencies[0])
- `$^`: Represents all dependencies (useful for linking multiple files)
- `$?`: Represents extra dependencies (files to watch for changes)

#### Incremental Build Process
1. **Check timestamps**: Compare target file modification time with dependency files
2. **Check .d files**: If `dependency_file=True`, parse .d files to check header dependencies
3. **Determine rebuild**: Rebuild if any dependency is newer than the target
4. **Execute command**: Run the build command only if rebuild is needed

Examples of using special variables:
```python
# Compile source files to objects with dependency tracking
builder.watch(
    ["main.o", "utils.o"],              # Object files to build
    ["main.cpp", "utils.cpp"],          # Source files
    "g++ -c $< -o $@ -Wall -MMD -MP",   # Compile with dependency generation
    dependency_file=True                # Enable .d file tracking
)

# Link multiple object files into executable
builder.watch(
    ["program.exe"],                    # $@ will be "program.exe"
    ["main.o", "utils.o", "math.o"],   # $^ will be "main.o utils.o math.o"
    "g++ $^ -o $@ -lraylib",           # Link all objects
    dependency_file=True                # Track dependencies for incremental linking
)

# Create static library from multiple objects
builder.watch(
    ["libmylib.a"],                     # Static library target
    ["obj1.o", "obj2.o", "obj3.o"],    # Object file dependencies
    "ar rcs $@ $^"                      # Archive command using all dependencies
)

# Watch extra files for changes
builder.watch(
    ["program.exe"],
    ["main.o"],
    "g++ $< -o $@",
    extra_dependencies=["config.h"],    # Rebuild if config.h changes
    dependency_file=True
)
```

### Utilities

#### `mmake.join_with_flag(paths, flag)`
Joins paths with a specific flag (e.g., `-I` for includes). Returns a string with all paths joined with the flag.

```python
INCLUDE_FLAGS = mmake.join_with_flag(include_paths, "-I")
# Result: "-I/path1 -I/path2 -I/path3"
```

#### `mmake.strip_lib_prefix(name)`
Removes the "lib" prefix from library names. Returns the library name without the prefix.

```python
lib_name = mmake.strip_lib_prefix("libraylib.a")
# Result: "raylib.a"
```

### Command Line Interface

#### `mmake.arguments_cmd(sys.argv, execute, install)`
Handles command-line arguments:
- `python build.py`: Runs `execute()`
- `python build.py install`: Runs `install()`

## Complete Example: Multi-Target C++ Project

This example demonstrates a complete build setup for a C++ project with external dependencies, static libraries, and multiple executables with incremental compilation.

### Project Structure
```
project/
├── src/
│   ├── include/          # Project headers
│   ├── lib/             # Library source files (.cpp)
│   └── target/          # Executable source files (.cpp)
├── .moonmake/
│   ├── obj/             # Generated object files
│   │   ├── lib/         # Library objects
│   │   └── target/      # Target objects
│   ├── lib/             # Generated static libraries
│   ├── bin/             # Final executables
│   └── dependencies/    # External dependencies
└── build.py             # This build script
```

### Complete Build Script

```python
import moonmake as mmake
import platform
import sys

dir_path = mmake.get_dir(__file__)
def join (*dir, separator="/"): return f"{separator}".join(dir).replace(r"\\","/")
def get_raylib_url():
    #Determines the Raylib download URL based on the operating system
    system = platform.system()
    BASE_URL = "https://github.com/raysan5/raylib/releases/download/5.5"
    
    if system == "Windows":
        return f"{BASE_URL}/raylib-5.5_win64_mingw-w64.zip"
    elif system == "Darwin":  # macOS
        return f"{BASE_URL}/raylib-5.5_macos.tar.gz"
    elif system == "Linux":
        return f"{BASE_URL}/raylib-5.5_linux_amd64.tar.gz"
    else:
        raise Exception(f"Unsupported system: {system}")

def install():
    #Downloads and installs the necessary dependencies.#
    raylib_url = get_raylib_url()
    mmake.download_dependency(
        raylib_url, 
        "raylib", 
        ".moonmake/dependencies", 
        headers=["include"]
    )

def execute():
    #Configures and executes the build process.#
    # Directories and configuration
    MOONMAKE_DIR = ".moonmake"
    PROJECT_NAME = "msrc"
    CPP_VERSION = "2b"
    EXTENSION = mmake.get_extension()
    
    # Important paths
    include_paths = [
        join(".", MOONMAKE_DIR, "dependencies", "headers"),
        join(".", dir_path, "src", "include")
    ]
    
    lib_paths = [
        join(MOONMAKE_DIR, "dependencies", "lib"),
        join( MOONMAKE_DIR, "lib")
    ]
    
 
    # Static libraries
    static_a_files = mmake.discover(join(".", MOONMAKE_DIR, "dependencies", "lib"), ".a")
    static_libs = [f"-l{mmake.strip_lib_prefix(a).replace('.a', '')}" for a in static_a_files]
    
    if platform.system() == "Windows":
        static_libs.extend(["-lgdi32", "-lwinmm","-mconsole"])
    
    # Compilation flags
    INCLUDE_FLAGS = mmake.join_with_flag(include_paths, "-I")
    LINK_FLAGS = mmake.join_with_flag(lib_paths, "-L")
    STATIC_LIBRARY = " ".join(static_libs)
    COMPILER_FLAGS = f"-Wall -Wextra -std=c++{CPP_VERSION} -Werror -O2"
    IGNORE_FLAGS = "-Wno-unused-parameter -Wno-return-type"  
    OBJ_FLAGS= "-MMD -MP"
    # Files to watch for changes
    static_watch_files = [join(MOONMAKE_DIR, "dependencies", "lib", a) for a in static_a_files]
    
    # Library files
    lib_files = [f for f in mmake.discover(join(dir_path, "src", "lib"), ".cpp")]
    lib_obj = mmake.change_extension(
        lib_files, 
        join(dir_path, MOONMAKE_DIR, "obj", "lib"), 
        old=".cpp", 
        new=".o"
    )
    lib_static = join(dir_path, MOONMAKE_DIR, "lib", f"lib{PROJECT_NAME}.a")
    
    # Target files (binaries)
    target_files = [f for f in mmake.discover(join(dir_path, "src", "target"), ".cpp")]
    target_obj = mmake.change_extension(
        target_files, 
        join(dir_path, MOONMAKE_DIR, "obj", "target"), 
        old=".cpp", 
        new=".o"
    )
    target_bin = mmake.change_extension(
        target_files, 
        join(dir_path, MOONMAKE_DIR, "bin"), 
        old=".cpp", 
        new=EXTENSION
    )
    
    # Configure the builder
    builder = mmake.Builder()
    
    # Rule to generate the final binaries
    builder.watch(
        target_bin, 
        target_obj, 
        f"g++ $< -o $@ {COMPILER_FLAGS} {LINK_FLAGS} {STATIC_LIBRARY} -l{PROJECT_NAME}",
    )
    
    # Rule to compile target object files
    builder.watch(
        target_obj, 
        [join(".", "src", "target", f) for f in target_files],
        f"g++ -c $< -o $@ {COMPILER_FLAGS} {INCLUDE_FLAGS} {IGNORE_FLAGS} {OBJ_FLAGS}",
        dependency_file=True
    )
    
    # Rule to create the static library
    builder.watch(
        [lib_static], 
        lib_obj, 
        "ar rcs $@ $^"
    )
    
    # Rule to compile library object files
    builder.watch(
        lib_obj, 
        [join(".", "src", "lib", f) for f in lib_files],
        f"g++ {COMPILER_FLAGS} {IGNORE_FLAGS} -c $< -o $@ {INCLUDE_FLAGS} {OBJ_FLAGS}",
        dependency_file=True
    )
    
    # Execute all build rules
    builder.compile_all()

if __name__ == "__main__":
    mmake.arguments_cmd(sys.argv, execute, install)
```

### Key Features Demonstrated

1. **Incremental Compilation**: Uses `-MMD -MP` flags and `dependency_file=True` to track header dependencies
2. **Multi-target Build**: Supports multiple executables from different source files
3. **Static Library Creation**: Builds and links custom static libraries
4. **External Dependencies**: Downloads and integrates external libraries (Raylib)
5. **Cross-platform Support**: Automatically handles platform-specific configurations

## Platform Support

- Windows (MinGW-w64)
- Linux
- macOS
